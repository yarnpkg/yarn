HTTP/1.1 200 OK
server: CouchDB/1.5.0 (Erlang OTP/R16B03)
etag: "7K59W23O6TAVF3JKC0QSAKXUM"
Content-Type: application/json
Cache-Control: max-age=300
Content-Length: 29883
Accept-Ranges: bytes
Date: Wed, 07 Sep 2016 14:24:37 GMT
Via: 1.1 varnish
Age: 0
Connection: keep-alive
X-Served-By: cache-iad2632-IAD
X-Cache: HIT
X-Cache-Hits: 1
X-Timer: S1473258277.355442,VS0,VE12
Vary: Accept-Encoding

{"_id":"pegjs","_rev":"35-831c15a343ec6363f76a80a4350062cf","name":"pegjs","description":"Parser generator for JavaScript","dist-tags":{"latest":"0.10.0"},"versions":{"0.6.0":{"name":"pegjs","version":"0.6.0","description":"Parser generator for JavaScript","homepage":"http://pegjs.majda.cz/","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"repository":{"type":"git","url":"git://github.com/dmajda/pegjs.git"},"devDependencies":{"jake":">= 0.1.10","uglify-js":">= 0.0.5"},"engines":{"node":">= 0.4.4"},"dependencies":{},"_id":"pegjs@0.6.0","_engineSupported":true,"_npmVersion":"1.0.1rc5","_nodeVersion":"v0.4.4","_defaultsLoaded":true,"dist":{"shasum":"fd3d100d37b82bc8e11f581f268811ffe788e578","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.6.0.tgz"},"directories":{}},"0.6.1":{"name":"pegjs","version":"0.6.1","description":"Parser generator for JavaScript","homepage":"http://pegjs.majda.cz/","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"repository":{"type":"git","url":"git://github.com/dmajda/pegjs.git"},"devDependencies":{"jake":">= 0.1.10","uglify-js":">= 0.0.5"},"engines":{"node":">= 0.4.4"},"dependencies":{},"_id":"pegjs@0.6.1","_engineSupported":true,"_npmVersion":"1.0.1rc5","_nodeVersion":"v0.4.4","_defaultsLoaded":true,"dist":{"shasum":"6eaf9330ff34e46d05e180f77013be892db178ac","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.6.1.tgz"},"directories":{}},"0.6.2":{"name":"pegjs","version":"0.6.2","description":"Parser generator for JavaScript","homepage":"http://pegjs.majda.cz/","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"repository":{"type":"git","url":"git://github.com/dmajda/pegjs.git"},"devDependencies":{"jake":">= 0.1.10","uglify-js":">= 0.0.5"},"engines":{"node":">= 0.4.4"},"_npmJsonOpts":{"file":"/home/dmajda/.npm/pegjs/0.6.2/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"pegjs@0.6.2","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.15","_nodeVersion":"v0.4.8","_defaultsLoaded":true,"dist":{"shasum":"74651f8a800e444db688e4eeae8edb65637a17a5","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.6.2.tgz"},"scripts":{},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"directories":{}},"0.7.0":{"name":"pegjs","version":"0.7.0","description":"Parser generator for JavaScript","homepage":"http://pegjs.majda.cz/","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"repository":{"type":"git","url":"git://github.com/dmajda/pegjs.git"},"devDependencies":{"uglify-js":">= 1.2.4","jshint":">= 0.5.5"},"engines":{"node":">= 0.6.6"},"_npmUser":{"name":"dmajda","email":"david@majda.cz"},"_id":"pegjs@0.7.0","dependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-beta-7","_nodeVersion":"v0.6.6","_defaultsLoaded":true,"dist":{"shasum":"aaa1f824f9e7197ec44e22a57af522f700dd689e","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.7.0.tgz"},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"directories":{}},"0.8.0":{"name":"pegjs","version":"0.8.0","description":"Parser generator for JavaScript","homepage":"http://pegjs.majda.cz/","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"files":["CHANGELOG.md","LICENSE","README.md","VERSION","bin/pegjs","examples/arithmetics.pegjs","examples/css.pegjs","examples/javascript.pegjs","examples/json.pegjs","lib/compiler.js","lib/compiler/opcodes.js","lib/compiler/passes/generate-bytecode.js","lib/compiler/passes/generate-javascript.js","lib/compiler/passes/remove-proxy-rules.js","lib/compiler/passes/report-left-recursion.js","lib/compiler/passes/report-missing-rules.js","lib/grammar-error.js","lib/parser.js","lib/peg.js","lib/utils.js","package.json"],"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"scripts":{"test":"make spec"},"repository":{"type":"git","url":"http://github.com/dmajda/pegjs.git"},"devDependencies":{"jasmine-node":"= 1.11.0","uglify-js":"= 2.4.7","jshint":"= 2.3.0"},"engines":{"node":">= 0.8"},"_id":"pegjs@0.8.0","dist":{"shasum":"976f067da13e5c5b1501c017925668a253811561","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.8.0.tgz"},"_from":".","_npmVersion":"1.2.14","_npmUser":{"name":"dmajda","email":"david@majda.cz"},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"directories":{}},"0.9.0":{"name":"pegjs","version":"0.9.0","description":"Parser generator for JavaScript","homepage":"http://pegjs.org/","license":"MIT","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"files":["CHANGELOG.md","LICENSE","README.md","VERSION","bin/pegjs","examples/arithmetics.pegjs","examples/css.pegjs","examples/javascript.pegjs","examples/json.pegjs","lib/compiler.js","lib/compiler/asts.js","lib/compiler/javascript.js","lib/compiler/opcodes.js","lib/compiler/visitor.js","lib/compiler/passes/generate-bytecode.js","lib/compiler/passes/generate-javascript.js","lib/compiler/passes/remove-proxy-rules.js","lib/compiler/passes/report-left-recursion.js","lib/compiler/passes/report-infinite-loops.js","lib/compiler/passes/report-missing-rules.js","lib/grammar-error.js","lib/parser.js","lib/peg.js","lib/utils/arrays.js","lib/utils/classes.js","lib/utils/objects.js","package.json"],"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"scripts":{"test":"make hint && make spec"},"repository":{"type":"git","url":"http://github.com/pegjs/pegjs.git"},"devDependencies":{"jasmine-node":"= 1.14.5","uglify-js":"= 2.4.24","jshint":"= 2.8.0"},"engines":{"node":">= 0.10.0"},"gitHead":"20a4fb2e7f70a0695bee4aef4984b24c06db3627","bugs":{"url":"https://github.com/pegjs/pegjs/issues"},"_id":"pegjs@0.9.0","_shasum":"f6aefa2e3ce56169208e52179dfe41f89141a369","_from":".","_npmVersion":"1.4.28","_npmUser":{"name":"dmajda","email":"david@majda.cz"},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"dist":{"shasum":"f6aefa2e3ce56169208e52179dfe41f89141a369","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.9.0.tgz"},"directories":{}},"0.10.0":{"name":"pegjs","version":"0.10.0","description":"Parser generator for JavaScript","keywords":["parser generator","PEG"],"homepage":"http://pegjs.org/","bugs":{"url":"https://github.com/pegjs/pegjs/issues"},"license":"MIT","author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"files":["CHANGELOG.md","LICENSE","README.md","VERSION","bin/pegjs","examples/arithmetics.pegjs","examples/css.pegjs","examples/javascript.pegjs","examples/json.pegjs","lib/compiler/asts.js","lib/compiler/index.js","lib/compiler/js.js","lib/compiler/opcodes.js","lib/compiler/passes/generate-bytecode.js","lib/compiler/passes/generate-js.js","lib/compiler/passes/remove-proxy-rules.js","lib/compiler/passes/report-duplicate-labels.js","lib/compiler/passes/report-duplicate-rules.js","lib/compiler/passes/report-infinite-recursion.js","lib/compiler/passes/report-infinite-repetition.js","lib/compiler/passes/report-undefined-rules.js","lib/compiler/visitor.js","lib/grammar-error.js","lib/parser.js","lib/peg.js","lib/utils/arrays.js","lib/utils/classes.js","lib/utils/objects.js","package.json"],"main":"lib/peg","bin":{"pegjs":"bin/pegjs"},"repository":{"type":"git","url":"git+https://github.com/pegjs/pegjs.git"},"scripts":{"test":"make lint && make spec"},"devDependencies":{"browserify":"13.1.0","eslint":"2.13.1","http-server":"0.9.0","jasmine-node":"1.14.5","uglify-js":"2.7.0"},"engines":{"node":">=0.10"},"gitHead":"671166bbe82150042b71d5756405c0ee067df961","_id":"pegjs@0.10.0","_shasum":"cf8bafae6eddff4b5a7efb185269eaaf4610ddbd","_from":".","_npmVersion":"3.8.6","_nodeVersion":"6.0.0","_npmUser":{"name":"dmajda","email":"david@majda.cz"},"dist":{"shasum":"cf8bafae6eddff4b5a7efb185269eaaf4610ddbd","tarball":"https://registry.npmjs.org/pegjs/-/pegjs-0.10.0.tgz"},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/pegjs-0.10.0.tgz_1471590993207_0.5759401724208146"},"directories":{}}},"maintainers":[{"name":"dmajda","email":"david@majda.cz"}],"time":{"modified":"2016-08-19T07:16:34.480Z","created":"2011-04-14T16:30:04.408Z","0.6.0":"2011-04-14T16:30:05.132Z","0.6.1":"2011-04-14T17:55:38.265Z","0.6.2":"2011-08-20T16:34:48.518Z","0.7.0":"2012-04-18T11:00:20.959Z","0.8.0":"2013-12-24T08:21:14.725Z","0.9.0":"2015-08-30T06:26:02.780Z","0.10.0":"2016-08-19T07:16:34.480Z"},"author":{"name":"David Majda","email":"david@majda.cz","url":"http://majda.cz/"},"repository":{"type":"git","url":"git+https://github.com/pegjs/pegjs.git"},"users":{"nak2k":true,"alexgo":true,"dape":true,"mimmo1":true,"ne_sachirou":true,"dnunez24":true,"hibrahimsafak":true,"briantrice":true,"nukisman":true,"detj":true,"monsterkodi":true,"jjdanois":true,"mccoyjordan":true,"leizongmin":true,"pastahito":true,"panlw":true},"homepage":"http://pegjs.org/","readme":"[![Build status](https://img.shields.io/travis/pegjs/pegjs.svg)](https://travis-ci.org/pegjs/pegjs)\n[![npm version](https://img.shields.io/npm/v/pegjs.svg)](https://www.npmjs.com/package/pegjs)\n[![Bower version](https://img.shields.io/bower/v/pegjs.svg)](https://github.com/pegjs/bower)\n[![License](https://img.shields.io/badge/license-mit-blue.svg)](https://opensource.org/licenses/MIT)\n\nPEG.js\n======\n\nPEG.js is a simple parser generator for JavaScript that produces fast parsers\nwith excellent error reporting. You can use it to process complex data or\ncomputer languages and build transformers, interpreters, compilers and other\ntools easily.\n\nFeatures\n--------\n\n  * Simple and expressive grammar syntax\n  * Integrates both lexical and syntactical analysis\n  * Parsers have excellent error reporting out of the box\n  * Based on [parsing expression\n    grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar) formalism\n    — more powerful than traditional LL(*k*) and LR(*k*) parsers\n  * Usable [from your browser](http://pegjs.org/online), from the command line,\n    or via JavaScript API\n\nGetting Started\n---------------\n\n[Online version](http://pegjs.org/online) is the easiest way to generate a\nparser. Just enter your grammar, try parsing few inputs, and download generated\nparser code.\n\nInstallation\n------------\n\n### Node.js\n\nTo use the `pegjs` command, install PEG.js globally:\n\n```console\n$ npm install -g pegjs\n```\n\nTo use the JavaScript API, install PEG.js locally:\n\n```console\n$ npm install pegjs\n```\n\nIf you need both the `pegjs` command and the JavaScript API, install PEG.js both\nways.\n\n### Browser\n\n[Download](http://pegjs.org/#download) the PEG.js library (regular or minified\nversion) or install it using Bower:\n\n```console\n$ bower install pegjs\n```\n\nGenerating a Parser\n-------------------\n\nPEG.js generates parser from a grammar that describes expected input and can\nspecify what the parser returns (using semantic actions on matched parts of the\ninput). Generated parser itself is a JavaScript object with a simple API.\n\n### Command Line\n\nTo generate a parser from your grammar, use the `pegjs` command:\n\n```console\n$ pegjs arithmetics.pegjs\n```\n\nThis writes parser source code into a file with the same name as the grammar\nfile but with “.js” extension. You can also specify the output file explicitly:\n\n```console\n$ pegjs -o arithmetics-parser.js arithmetics.pegjs\n```\n\nIf you omit both input and output file, standard input and output are used.\n\nBy default, the generated parser is in the Node.js module format. You can\noverride this using the `--format` option.\n\nYou can tweak the generated parser with several options:\n\n  * `--allowed-start-rules` — comma-separated list of rules the parser will be\n    allowed to start parsing from (default: the first rule in the grammar)\n  * `--cache` — makes the parser cache results, avoiding exponential parsing\n    time in pathological cases but making the parser slower\n  * `--dependency` — makes the parser require a specified dependency (can be\n    specified multiple times)\n  * `--export-var` — name of a global variable into which the parser object is\n    assigned to when no module loader is detected\n  * `--extra-options` — additional options (in JSON format) to pass to\n    `peg.generate`\n  * `--extra-options-file` — file with additional options (in JSON format) to\n    pass to `peg.generate`\n  * `--format` — format of the generated parser: `amd`, `commonjs`, `globals`,\n    `umd` (default: `commonjs`)\n  * `--optimize` — selects between optimizing the generated parser for parsing\n    speed (`speed`) or code size (`size`) (default: `speed`)\n  * `--plugin` — makes PEG.js use a specified plugin (can be specified multiple\n    times)\n  * `--trace` — makes the parser trace its progress\n\n### JavaScript API\n\nIn Node.js, require the PEG.js parser generator module:\n\n```javascript\nvar peg = require(\"pegjs\");\n```\n\nIn browser, include the PEG.js library in your web page or application using the\n`<script>` tag. If PEG.js detects an AMD loader, it will define itself as a\nmodule, otherwise the API will be available in the `peg` global object.\n\nTo generate a parser, call the `peg.generate` method and pass your grammar as a\nparameter:\n\n```javascript\nvar parser = peg.generate(\"start = ('a' / 'b')+\");\n```\n\nThe method will return generated parser object or its source code as a string\n(depending on the value of the `output` option — see below). It will throw an\nexception if the grammar is invalid. The exception will contain `message`\nproperty with more details about the error.\n\nYou can tweak the generated parser by passing a second parameter with an options\nobject to `peg.generate`. The following options are supported:\n\n  * `allowedStartRules` — rules the parser will be allowed to start parsing from\n    (default: the first rule in the grammar)\n  * `cache` — if `true`, makes the parser cache results, avoiding exponential\n    parsing time in pathological cases but making the parser slower (default:\n    `false`)\n  * `dependencies` — parser dependencies, the value is an object which maps\n    variables used to access the dependencies in the parser to module IDs used\n    to load them; valid only when `format` is set to `\"amd\"`, `\"commonjs\"`, or\n    `\"umd\"` (default: `{}`)\n  * `exportVar` — name of a global variable into which the parser object is\n    assigned to when no module loader is detected; valid only when `format` is\n    set to `\"globals\"` or `\"umd\"` (default: `null`)\n  * `format` — format of the genreated parser (`\"amd\"`, `\"bare\"`, `\"commonjs\"`,\n    `\"globals\"`, or `\"umd\"`); valid only when `output` is set to `\"source\"`\n    (default: `\"bare\"`)\n  * `optimize`— selects between optimizing the generated parser for parsing\n    speed (`\"speed\"`) or code size (`\"size\"`) (default: `\"speed\"`)\n  * `output` — if set to `\"parser\"`, the method will return generated parser\n    object; if set to `\"source\"`, it will return parser source code as a string\n    (default: `\"parser\"`)\n  * `plugins` — plugins to use\n  * `trace` — makes the parser trace its progress (default: `false`)\n\nUsing the Parser\n----------------\n\nUsing the generated parser is simple — just call its `parse` method and pass an\ninput string as a parameter. The method will return a parse result (the exact\nvalue depends on the grammar used to generate the parser) or throw an exception\nif the input is invalid. The exception will contain `location`, `expected`,\n`found`,  and `message` properties with more details about the error.\n\n```javascript\nparser.parse(\"abba\"); // returns [\"a\", \"b\", \"b\", \"a\"]\n\nparser.parse(\"abcd\"); // throws an exception\n```\n\nYou can tweak parser behavior by passing a second parameter with an options\nobject to the `parse` method. The following options are supported:\n\n  * `startRule` — name of the rule to start parsing from\n  * `tracer` — tracer to use\n\nParsers can also support their own custom options.\n\nGrammar Syntax and Semantics\n----------------------------\n\nThe grammar syntax is similar to JavaScript in that it is not line-oriented and\nignores whitespace between tokens. You can also use JavaScript-style comments\n(`// ...` and `/* ... */`).\n\nLet's look at example grammar that recognizes simple arithmetic expressions like\n`2*(3+4)`. A parser generated from this grammar computes their values.\n\n```pegjs\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }\n```\n\nOn the top level, the grammar consists of *rules* (in our example, there are\nfive of them). Each rule has a *name* (e.g. `integer`) that identifies the rule,\nand a *parsing expression* (e.g. `digits:[0-9]+ { return\nparseInt(digits.join(\"\"), 10); }`) that defines a pattern to match against the\ninput text and possibly contains some JavaScript code that determines what\nhappens when the pattern matches successfully. A rule can also contain\n*human-readable name* that is used in error messages (in our example, only the\n`integer` rule has a human-readable name). The parsing starts at the first rule,\nwhich is also called the *start rule*.\n\nA rule name must be a JavaScript identifier. It is followed by an equality sign\n(“=”) and a parsing expression. If the rule has a human-readable name, it is\nwritten as a JavaScript string between the name and separating equality sign.\nRules need to be separated only by whitespace (their beginning is easily\nrecognizable), but a semicolon (“;”) after the parsing expression is allowed.\n\nThe first rule can be preceded by an *initializer* — a piece of JavaScript code\nin curly braces (“{” and “}”). This code is executed before the generated parser\nstarts parsing. All variables and functions defined in the initializer are\naccessible in rule actions and semantic predicates. The code inside the\ninitializer can access options passed to the parser using the `options`\nvariable. Curly braces in the initializer code must be balanced. Let's look at\nthe example grammar from above using a simple initializer.\n\n```pegjs\n{\n  function makeInteger(o) {\n    return parseInt(o.join(\"\"), 10);\n  }\n}\n\nstart\n  = additive\n\nadditive\n  = left:multiplicative \"+\" right:additive { return left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary \"*\" right:multiplicative { return left * right; }\n  / primary\n\nprimary\n  = integer\n  / \"(\" additive:additive \")\" { return additive; }\n\ninteger \"integer\"\n  = digits:[0-9]+ { return makeInteger(digits); }\n```\n\nThe parsing expressions of the rules are used to match the input text to the\ngrammar. There are various types of expressions — matching characters or\ncharacter classes, indicating optional parts and repetition, etc. Expressions\ncan also contain references to other rules. See detailed description below.\n\nIf an expression successfully matches a part of the text when running the\ngenerated parser, it produces a *match result*, which is a JavaScript value. For\nexample:\n\n  * An expression matching a literal string produces a JavaScript string\n    containing matched text.\n  * An expression matching repeated occurrence of some subexpression produces a\n    JavaScript array with all the matches.\n\nThe match results propagate through the rules when the rule names are used in\nexpressions, up to the start rule. The generated parser returns start rule's\nmatch result when parsing is successful.\n\nOne special case of parser expression is a *parser action* — a piece of\nJavaScript code inside curly braces (“{” and “}”) that takes match results of\nsome of the the preceding expressions and returns a JavaScript value. This value\nis considered match result of the preceding expression (in other words, the\nparser action is a match result transformer).\n\nIn our arithmetics example, there are many parser actions. Consider the action\nin expression `digits:[0-9]+ { return parseInt(digits.join(\"\"), 10); }`. It\ntakes the match result of the expression [0-9]+, which is an array of strings\ncontaining digits, as its parameter. It joins the digits together to form a\nnumber and converts it to a JavaScript `number` object.\n\n### Parsing Expression Types\n\nThere are several types of parsing expressions, some of them containing\nsubexpressions and thus forming a recursive structure:\n\n#### \"*literal*\"<br>'*literal*'\n\nMatch exact literal string and return it. The string syntax is the same as in\nJavaScript. Appending `i` right after the literal makes the match\ncase-insensitive.\n\n#### .\n\nMatch exactly one character and return it as a string.\n\n#### [*characters*]\n\nMatch one character from a set and return it as a string. The characters in the\nlist can be escaped in exactly the same way as in JavaScript string. The list of\ncharacters can also contain ranges (e.g. `[a-z]` means “all lowercase letters”).\nPreceding the characters with `^` inverts the matched set (e.g. `[^a-z]` means\n“all character but lowercase letters”). Appending `i` right after the right\nbracket makes the match case-insensitive.\n\n#### *rule*\n\nMatch a parsing expression of a rule recursively and return its match result.\n\n#### ( *expression* )\n\nMatch a subexpression and return its match result.\n\n#### *expression* \\*\n\nMatch zero or more repetitions of the expression and return their match results\nin an array. The matching is greedy, i.e. the parser tries to match the\nexpression as many times as possible. Unlike in regular expressions, there is no\nbacktracking.\n\n#### *expression* +\n\nMatch one or more repetitions of the expression and return their match results\nin an array. The matching is greedy, i.e. the parser tries to match the\nexpression as many times as possible. Unlike in regular expressions, there is no\nbacktracking.\n\n#### *expression* ?\n\nTry to match the expression. If the match succeeds, return its match result,\notherwise return `null`. Unlike in regular expressions, there is no\nbacktracking.\n\n#### & *expression*\n\nTry to match the expression. If the match succeeds, just return `undefined` and\ndo not consume any input, otherwise consider the match failed.\n\n#### ! *expression*\n\nTry to match the expression. If the match does not succeed, just return\n`undefined` and do not consume any input, otherwise consider the match failed.\n\n#### & { *predicate* }\n\nThe predicate is a piece of JavaScript code that is executed as if it was inside\na function. It gets the match results of labeled expressions in preceding\nexpression as its arguments. It should return some JavaScript value using the\n`return` statement. If the returned value evaluates to `true` in boolean\ncontext, just return `undefined` and do not consume any input; otherwise\nconsider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in\nthe initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the\n`location` function. It returns an object like this:\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\n\nThe `start` and `end` properties both refer to the current parse position. The\n`offset` property contains an offset as a zero-based index and `line` and\n`column` properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using\nthe `options` variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n#### ! { *predicate* }\n\nThe predicate is a piece of JavaScript code that is executed as if it was inside\na function. It gets the match results of labeled expressions in preceding\nexpression as its arguments. It should return some JavaScript value using the\n`return` statement. If the returned value evaluates to `false` in boolean\ncontext, just return `undefined` and do not consume any input; otherwise\nconsider the match failed.\n\nThe code inside the predicate can access all variables and functions defined in\nthe initializer at the beginning of the grammar.\n\nThe code inside the predicate can also access location information using the\n`location` function. It returns an object like this:\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 23, line: 5, column: 6 }\n}\n```\n\nThe `start` and `end` properties both refer to the current parse position. The\n`offset` property contains an offset as a zero-based index and `line` and\n`column` properties contain a line and a column as one-based indices.\n\nThe code inside the predicate can also access options passed to the parser using\nthe `options` variable.\n\nNote that curly braces in the predicate code must be balanced.\n\n#### $ *expression*\n\nTry to match the expression. If the match succeeds, return the matched text\ninstead of the match result.\n\n#### *label* : *expression*\n\nMatch the expression and remember its match result under given label. The label\nmust be a JavaScript identifier.\n\nLabeled expressions are useful together with actions, where saved match results\ncan be accessed by action's JavaScript code.\n\n#### *expression<sub>1</sub>* *expression<sub>2</sub>* ...  *expression<sub>n</sub>*\n\nMatch a sequence of expressions and return their match results in an array.\n\n#### *expression* { *action* }\n\nMatch the expression. If the match is successful, run the action, otherwise\nconsider the match failed.\n\nThe action is a piece of JavaScript code that is executed as if it was inside a\nfunction. It gets the match results of labeled expressions in preceding\nexpression as its arguments. The action should return some JavaScript value\nusing the `return` statement. This value is considered match result of the\npreceding expression.\n\nTo indicate an error, the code inside the action can invoke the `expected`\nfunction, which makes the parser throw an exception. The function takes two\nparameters — a description of what was expected at the current position and\noptional location information (the default is what `location` would return — see\nbelow). The description will be used as part of a message of the thrown\nexception.\n\nThe code inside an action can also invoke the `error` function, which also makes\nthe parser throw an exception. The function takes two parameters — an error\nmessage and optional location information (the default is what `location` would\nreturn — see below). The message will be used by the thrown exception.\n\nThe code inside the action can access all variables and functions defined in the\ninitializer at the beginning of the grammar. Curly braces in the action code\nmust be balanced.\n\nThe code inside the action can also access the text matched by the expression\nusing the `text` function.\n\n\nThe code inside the action can also access location information using the\n`location` function. It returns an object like this:\n\n```javascript\n{\n  start: { offset: 23, line: 5, column: 6 },\n  end:   { offset: 25, line: 5, column: 8 }\n}\n```\n\nThe `start` property refers to the position at the beginning of the expression,\nthe `end` property refers to position after the end of the expression. The\n`offset` property contains an offset as a zero-based index and `line` and\n`column` properties contain a line and a column as one-based indices.\n\nThe code inside the action can also access options passed to the parser using\nthe `options` variable.\n\nNote that curly braces in the action code must be balanced.\n\n#### *expression<sub>1</sub>* / *expression<sub>2</sub>* / ... / *expression<sub>n</sub>*\n\nTry to match the first expression, if it does not succeed, try the second one,\netc. Return the match result of the first successfully matched expression. If no\nexpression matches, consider the match failed.\n\nCompatibility\n-------------\n\nBoth the parser generator and generated parsers should run well in the following\nenvironments:\n\n  * Node.js 0.10.0+\n  * Internet Explorer 8+\n  * Edge\n  * Firefox\n  * Chrome\n  * Safari\n  * Opera\n\nDevelopment\n-----------\n\n  * [Project website](http://pegjs.org/)\n  * [Wiki](https://github.com/pegjs/pegjs/wiki)\n  * [Source code](https://github.com/pegjs/pegjs)\n  * [Issue tracker](https://github.com/pegjs/pegjs/issues)\n  * [Google Group](http://groups.google.com/group/pegjs)\n  * [Twitter](http://twitter.com/peg_js)\n\nPEG.js is developed by [David Majda](http://majda.cz/)\n([@dmajda](http://twitter.com/dmajda)). The [Bower\npackage](https://github.com/pegjs/bower) is maintained by [Michel\nKrämer](http://www.michel-kraemer.com/)\n([@michelkraemer](https://twitter.com/michelkraemer)).\n\nYou are welcome to contribute code.  Unless your contribution is really trivial\nyou should get in touch with me first — this can prevent wasted effort on both\nsides. You can send code both as a patch or a GitHub pull request.\n\nNote that PEG.js is still very much work in progress. There are no compatibility\nguarantees until version 1.0.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/pegjs/pegjs/issues"},"license":"MIT","keywords":["parser generator","PEG"],"_attachments":{}}